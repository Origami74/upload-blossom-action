import { NostrFilter, NostrRelayCLOSED, NostrRelayEOSE, NostrRelayEVENT, NRelay } from "@jsr/nostrify__types";
import { NostrEvent } from "nostr-tools";
export interface NPoolOpts<T extends NRelay> {
  /** Creates an `NRelay` instance for the given URL. */ open(url: string): T;
  /** Determines the relays to use for making `REQ`s to the given filters. To support the Outbox model, it should analyze the `authors` field of the filters. */ reqRouter(filters: NostrFilter[]): Promise<ReadonlyMap<string, NostrFilter[]>>;
  /** Determines the relays to use for publishing the given event. To support the Outbox model, it should analyze the `pubkey` field of the event. */ eventRouter(event: NostrEvent): Promise<string[]>;
}
/**
 * The `NPool` class is a `NRelay` implementation for connecting to multiple relays.
 *
 * ```ts
 * const pool = new NPool({
 *   open: (url) => new NRelay1(url),
 *   reqRouter: async (filters) => new Map([
 *     ['wss://relay1.mostr.pub', filters],
 *     ['wss://relay2.mostr.pub', filters],
 *   ]),
 *   eventRouter: async (event) => ['wss://relay1.mostr.pub', 'wss://relay2.mostr.pub'],
 * });
 *
 * // Now you can use the pool like a regular relay.
 * for await (const msg of pool.req([{ kinds: [1] }])) {
 *   if (msg[0] === 'EVENT') console.log(msg[2]);
 *   if (msg[0] === 'EOSE') break;
 * }
 * ```
 *
 * This class is designed with the Outbox model in mind.
 * Instead of passing relay URLs into each method, you pass functions into the contructor that statically-analyze filters and events to determine which relays to use for requesting and publishing events.
 * If a relay wasn't already connected, it will be opened automatically.
 * Defining `open` will also let you use any relay implementation, such as `NRelay1`.
 *
 * Note that `pool.req` may stream duplicate events, while `pool.query` will correctly process replaceable events and deletions within the event set before returning them.
 *
 * `pool.req` will only emit an `EOSE` when all relays in its set have emitted an `EOSE`, and likewise for `CLOSED`.
 */ export declare class NPool<T extends NRelay> implements NRelay {
  private opts: any;
  private _relays: any;
  constructor(opts: NPoolOpts<T>);
  /** Get or create a relay instance for the given URL. */ public relay(url: string): T;
  public get relays(): ReadonlyMap<string, T>;
  req(filters: NostrFilter[], opts?: {
    signal?: AbortSignal;
  }): AsyncIterable<NostrRelayEVENT | NostrRelayEOSE | NostrRelayCLOSED>;
  event(event: NostrEvent, opts?: {
    signal?: AbortSignal;
  }): Promise<void>;
  query(filters: NostrFilter[], opts?: {
    signal?: AbortSignal;
  }): Promise<NostrEvent[]>;
  /** Close all the relays in the pool. */ close(): Promise<void>;
}
//# sourceMappingURL=NPool.d.ts.map