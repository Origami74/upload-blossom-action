import { getBlobSha256 } from "./helpers.js";
import { createDeleteAuth, createDownloadAuth, createListAuth, createUploadAuth, encodeAuthorizationHeader, } from "./auth.js";
import { mirrorBlob } from "./actions/mirror.js";
import { uploadBlob } from "./actions/upload.js";
import { listBlobs } from "./actions/list.js";
import { downloadBlob } from "./actions/download.js";
import { deleteBlob } from "./actions/delete.js";
export class BlossomClient {
    server;
    signer;
    payment;
    constructor(server, signer) {
        this.server = new URL("/", server);
        this.signer = signer;
    }
    // moved to helpers.ts
    static getFileSha256 = getBlobSha256;
    // static auth methods moved to auth.ts
    static createGetAuth = createDownloadAuth;
    static createUploadAuth = createUploadAuth;
    static createListAuth = createListAuth;
    static createDeleteAuth = createDeleteAuth;
    // util
    static encodeAuthorizationHeader = encodeAuthorizationHeader;
    // static blob methods moved to actions
    static mirrorBlob = mirrorBlob;
    static uploadBlob = uploadBlob;
    static listBlobs = listBlobs;
    static downloadBlob = downloadBlob;
    static deleteBlob = deleteBlob;
    // download blob
    async createDownloadAuth(message, hash, expiration) {
        if (!this.signer)
            throw new Error("Missing signer");
        return await createDownloadAuth(this.signer, hash, message, expiration);
    }
    async downloadBlob(hash, opts) {
        const options = { signal: opts?.signal };
        // attach auth
        if (opts?.auth !== false) {
            if (typeof opts?.auth === "object")
                options.auth = opts.auth;
            if (this.signer)
                options.auth = await this.createDownloadAuth(`Download ${hash}`, hash);
        }
        // attach payment
        if (opts?.payment !== false && this.payment)
            options.onPayment = this.payment.download;
        const download = await downloadBlob(this.server, hash, options);
        return download.blob();
    }
    // upload blob
    async createUploadAuth(blob, message, expiration) {
        if (!this.signer)
            throw new Error("Missing signer");
        const hash = await getBlobSha256(blob);
        return await createUploadAuth(this.signer, hash, message, expiration);
    }
    async uploadBlob(blob, opts) {
        const options = { signal: opts?.signal };
        // attach auth
        if (opts?.auth !== false) {
            if (typeof opts?.auth === "object")
                options.auth = opts.auth;
            if (this.signer)
                options.auth = await this.createUploadAuth(blob);
        }
        // attach payment
        if (opts?.payment !== false && this.payment)
            options.onPayment = this.payment.upload;
        return uploadBlob(this.server, blob, options);
    }
    // mirror blob
    async createMirrorAuth(blob, message, expiration) {
        if (!this.signer)
            throw new Error("Missing signer");
        return await createUploadAuth(this.signer, typeof blob === "string" ? blob : blob.sha256, message, expiration);
    }
    async mirrorBlob(blob, opts) {
        const options = { signal: opts?.signal };
        // attach auth
        if (opts?.auth !== false) {
            if (typeof opts?.auth === "object")
                options.auth = opts.auth;
            if (this.signer)
                options.auth = await this.createMirrorAuth(blob);
        }
        // attach payment
        if (opts?.payment !== false && this.payment)
            options.onPayment = this.payment.mirror;
        return mirrorBlob(this.server, blob, options);
    }
    // has blob
    static async hasBlob(server, hash) {
        const res = await fetch(new URL(`/` + hash, server), { method: "HEAD" });
        return res.status !== 404;
    }
    async hasBlob(hash) {
        return BlossomClient.hasBlob(this.server, hash);
    }
    // list blobs
    async createListAuth(message, expiration) {
        if (!this.signer)
            throw new Error("Missing signer");
        return await createListAuth(this.signer, message, expiration);
    }
    async listBlobs(pubkey, opts) {
        const options = { signal: opts?.signal };
        // attach auth
        if (opts?.auth !== false) {
            if (typeof opts?.auth === "object")
                options.auth = opts.auth;
            if (this.signer)
                options.auth = await this.createListAuth();
        }
        // attach payment
        if (opts?.payment !== false && this.payment)
            options.onPayment = this.payment.list;
        return listBlobs(this.server, pubkey, options);
    }
    // delete blob
    async createDeleteAuth(hash, message, expiration) {
        if (!this.signer)
            throw new Error("Missing signer");
        return await createDeleteAuth(this.signer, hash, message, expiration);
    }
    async deleteBlob(hash, opts) {
        const options = { signal: opts?.signal };
        // attach auth
        if (opts?.auth !== false) {
            if (typeof opts?.auth === "object")
                options.auth = opts.auth;
            if (this.signer)
                options.auth = await this.createListAuth();
        }
        // attach payment
        if (opts?.payment !== false && this.payment)
            options.onPayment = this.payment.delete;
        return BlossomClient.deleteBlob(this.server, hash, options);
    }
}
